사용자가 Kotlin in Action을 읽고 정리한 .md 파일을 검토하는 명령어입니다.

## 입력

$ARGUMENTS 에 검토할 .md 파일 경로가 들어옵니다. (예: docs/ch02_코틀린_기초.md)

## 핵심 원칙: 정리된 내용에 한해서만 리뷰

**이 원칙은 모든 단계에서 반드시 지켜야 합니다.**

사용자는 한 챕터를 한번에 다 정리하지 않습니다. 절(section) 단위로 나눠서 점진적으로 정리하고 커밋합니다.
따라서:

- **사용자가 실제로 작성한 내용에 대해서만** 검토, 보충, 예제 생성을 수행합니다.
- .md 파일에 아직 작성되지 않은 절/주제는 **절대 임의로 채우지 않습니다.**
- 체크리스트 대비 아직 다루지 않은 내용이 있으면, "아직 정리되지 않은 항목"으로 별도 안내만 합니다.
- 보충(Step 2)도 사용자가 작성한 내용의 부정확/불완전한 부분만 보완하며, 아예 새로운 절을 추가하지 않습니다.
- 예제 코드(Step 3)도 사용자가 정리한 개념에 대해서만 생성합니다.

## 실행할 작업

해당 .md 파일을 읽고 아래 3단계를 순서대로 수행하세요.

### Step 1: 검토 (Review)

**검토 범위: 사용자가 작성한 내용에 한정**

**정확성 검증:**
- 작성된 내용 중 잘못된 코틀린 개념 설명이 있는지 확인
- 작성된 코드 예제에 문법 오류나 잘못된 사용법이 있는지 확인
- 작성된 Java와의 비교가 정확한지 확인

**완성도 검증 (아래 챕터별 체크리스트 참고):**
- 작성된 내용 안에서 설명이 불충분하거나 핵심이 빠진 부분이 있는지 확인
- 작성된 내용에 관련된 주의사항(pitfall)이 누락되었는지 확인
- 작성된 내용에서 Java 개발자 관점의 차이점이 빠졌는지 확인
- 챕터 체크리스트 대비 **아직 정리되지 않은 항목**은 마지막에 별도로 목록만 안내 (내용을 채우지 않음)

### Step 2: 보충 (Supplement)

**보충 범위: 사용자가 작성한 내용의 보완만. 새로운 절/주제 추가 금지.**

원본 .md 파일에서 부정확하거나 불완전한 부분만 보충합니다:
- 추가 내용은 `> 💡 **보충**:` blockquote로 구분
- 수정 내용은 `> ⚠️ **수정**:` blockquote로 구분
- 원본 구조와 스타일을 최대한 존중
- 사용자가 아직 작성하지 않은 절에 대해서는 어떤 내용도 추가하지 않음

### Step 3: 예제 코드 생성 (Code Generation)

**생성 범위: 사용자가 정리한 개념에 대해서만 예제를 생성합니다. 아직 정리하지 않은 개념의 예제는 만들지 않습니다.**

해당 챕터에서 사용자가 정리한 개념마다 실행 가능한 .kt 파일을 생성합니다:
- 위치: `src/main/kotlin/ch{번호}/` 디렉토리
- 모든 파일에 `fun main()` 포함 (IntelliJ에서 바로 실행 가능)
- package 선언: `package ch{번호}`
- 한글 주석으로 설명 포함
- Java와의 차이점이 있으면 주석으로 비교

예제 코드 형식:
```kotlin
package ch02

/**
 * [개념 이름]
 *
 * - 핵심 설명
 * - Java와의 차이점 (있을 경우)
 */

fun main() {
    println("=== 개념 이름 ===")

    // 예제 1: 기본 사용법
    // 설명
    println("결과")

    // 예제 2: 심화 사용법
    // 설명
    println("결과")
}
```

## 출력 형식

터미널에 다음 형식으로 검토 결과를 출력한 뒤, 파일을 생성/수정합니다:

```
## 📋 검토 결과

### ✅ 잘 정리된 부분
- ...

### ⚠️ 수정이 필요한 부분
- [항목]: 현재 내용 → 수정 제안

### 📌 보충하면 좋을 내용
- ...

### 💡 Java 개발자를 위한 추가 팁
- ...

### 📝 아직 정리되지 않은 항목 (참고용)
- 챕터 체크리스트 기준으로 아직 .md에 작성되지 않은 항목 나열
- (이 항목들은 사용자가 추후 정리할 예정이므로 내용을 채우지 않음)

### 📁 생성된 파일
- docs/ch02_xxx.md (보충 완료)
- src/main/kotlin/ch02/Variables.kt
- src/main/kotlin/ch02/WhenExample.kt
```

## 챕터별 핵심 체크리스트

### Chapter 1: 코틀린이란 무엇이며, 왜 필요한가?
- 코틀린의 주요 특성 (정적 타입, 간결성, 안전성, 상호운용성)
- 코틀린의 철학
- 코틀린 서버/안드로이드 활용
- 코틀린 빌드 과정

### Chapter 2: 코틀린 기초
- 함수 (fun, 식이 본문인 함수)
- 변수 (val vs var)
- 문자열 템플릿
- 클래스와 프로퍼티
- enum과 when
- 스마트 캐스트
- 이터레이션 (while, for, 범위, 수열)
- 예외 처리 (try는 식)

### Chapter 3: 함수 정의와 호출
- 컬렉션 만들기
- 함수 호출 (이름 붙인 인자, 디폴트 파라미터)
- 확장 함수와 확장 프로퍼티
- 컬렉션 처리 (가변 인자, 중위 호출, 구조 분해)
- 문자열과 정규식
- 로컬 함수

### Chapter 4: 클래스, 객체, 인터페이스
- 인터페이스 (디폴트 메소드)
- open, final, abstract
- 가시성 변경자
- 내부 클래스와 중첩 클래스
- sealed 클래스
- 생성자 (주 생성자, 부 생성자)
- data 클래스
- 클래스 위임 (by)
- object 키워드 (싱글턴, 동반 객체, 무명 객체)

### Chapter 5: 람다로 프로그래밍
- 람다 식과 멤버 참조
- 컬렉션 함수형 API (filter, map, all, any, count, find, groupBy, flatMap)
- 지연 계산(lazy) 컬렉션 연산 (시퀀스)
- SAM 변환
- 수신 객체 지정 람다 (with, apply)

### Chapter 6: 코틀린 타입 시스템
- 널 가능성 (?, ?., ?:, !!, let, lateinit)
- 코틀린 원시 타입
- 컬렉션과 배열 (읽기 전용 vs 변경 가능)

### Chapter 7: 연산자 오버로딩과 기타 관례
- 산술 연산자 오버로딩
- 비교 연산자 오버로딩
- 컬렉션 관례 (get, set, in, rangeTo)
- 구조 분해 선언
- 위임 프로퍼티

### Chapter 8: 고차 함수
- 함수 타입
- 인라인 함수
- 고차 함수 흐름 제어 (return, 레이블)

### Chapter 9: 제네릭스
- 타입 파라미터
- 실행 시 제네릭스 (타입 소거, reified)
- 변성 (공변성 out, 반공변성 in, 스타 프로젝션)

### Chapter 10: 애노테이션과 리플렉션
- 애노테이션 선언과 적용
- 리플렉션 (KClass, KCallable, KFunction, KProperty)

### Chapter 11: DSL 만들기
- 수신 객체 지정 람다와 DSL
- invoke 관례
- 실전 DSL 예제

## Java → Kotlin 전환 포인트 (검토 시 특별히 체크)

- val vs var ↔ final vs non-final
- 데이터 클래스 ↔ Java record / lombok @Data
- null safety ↔ Optional, @Nullable
- 확장 함수 ↔ static utility 메서드
- when ↔ switch
- sealed class ↔ Java 17 sealed class
- companion object ↔ static
- object ↔ singleton pattern
- by 위임 ↔ decorator pattern

## 주의사항

- 원본 .md의 구조와 스타일을 최대한 존중할 것
- 사용자가 이미 잘 정리한 부분은 건드리지 않을 것
- 예제 코드는 책의 해당 챕터 수준에 맞출 것 (아직 안 배운 개념은 사용하지 않기)
- 반드시 kotlin-in-action 모듈 기준 경로로 파일을 생성할 것